`timescale 1ns/1ps

module speed#(
	parameter width = 9,
	parameter depth = 9
	//parameter 
)
(
	input 									clk,
	input 									rst_n,
	input 									start,
	input[width - 1:0] 					i_car,	
	input[width - 1:0] 					i_x,
	input[width - 1:0] 					i_y,
	output reg[width - 1:0] 			o_x,
	output reg[width - 1:0] 			o_y,
	output reg[depth	  :0] 			o_idx,
	output reg[depth    :0] 			o_idy,
	output reg[width - 1:0]				o_speed,
	output reg[depth - 1:0]				o_id,
	output reg								o_wen_speed,
	output reg								o_wen_location
	//output[width - 1:0] x, y
);

localparam idle_state = 4;
localparam id_state = 0;
localparam x_state = 1;
localparam y_state = 2;
localparam math_state = 3;

//localparam t 

reg[width - 1:0] id_reg, x_reg, y_reg;
//reg[width : 0] x_addr, y_addr;
//reg[depth - 1:0] o_idx, o_idy,
reg[2:0] state, next_state;
reg speed_allow;

/*assign x = x_reg;
assign y = y_reg;*/



always@(posedge clk or negedge rst_n) begin
	if(!rst_n)
		state <= idle_state;
	else state <= next_state;
	/*else 
		case(state)
			idle_state: state <= (start) ? id_state : idle_state;
			id_state: state <= x_state;
			x_state: state <= y_state;
			y_state: state <= math_state;
			math_state: state <= id_state;
			default: state <= idle_state;
	endcase*/
	end

always@(*) begin
	case(state)
		#1
		idle_state: next_state <= (start) ? id_state : idle_state;
		id_state: next_state <= x_state;
		x_state: next_state <= y_state;
		y_state: next_state <= math_state;
		math_state: next_state <= id_state;
		default: next_state <= idle_state;
	endcase
end


always@(posedge clk) begin
	case(next_state) 
		idle_state: begin
			//id_reg <= 0;
			//x_reg <= 0;
			//y_reg <= 0;
			o_x <= 0;
			o_y <= 0;
			o_idx <= 0;
			o_idy <= 0;
			o_speed <= 0;
			o_id <= 0;
			//o_wen_location <= 0;
			//o_wen_speed <= 0;
			speed_allow <= 0;
			//n <= 0;
			//nn <= 0;
		end
		id_state: begin
			// do something
		end
		x_state: begin
			o_id <= id_reg;
			o_idx <= id_reg;
			o_idy <= id_reg + (2 ** (depth - 1));
			//o_wen_location <= 0;
		end
		y_state: begin
			// do something
		end
		math_state: begin
			o_x <= x_reg;
			o_y <= y_reg;
			/*o_id <= id_reg;
			o_idx <= id_reg;
			o_idy <= id_reg + (2 ** (depth - 1));*/
			if(i_x == 0 && i_y == 0) begin	//New car
				speed_allow <= 0;
			end
			else begin		//Old car, caculate velocity		
				if(y_reg < i_y) begin
					if(i_y < 300) begin
						//n <= ((i_y - y_reg) >> 2) + ((i_y - y_reg) >> 1);
						//nn <= (n << 1) + n; 
						o_speed <= ((i_y - y_reg) << 2) + ((i_y - y_reg) >> 1);
					end
					else begin
						//n <= ((i_y - y_reg) >> 2) + (i_y - y_reg) ;
						//nn <= (n << 2) + n;
						o_speed <= ((i_y - y_reg) >> 1) + ((i_y - y_reg) << 1) ;
					end
					speed_allow <= 1;
				end
				else speed_allow <= 0;
			end
		end
		default: begin
			o_x <= 0;
			o_y <= 0;
			o_idx <= 0;
			o_idy <= 0;
			o_speed <= 0;
			o_id <= 0;
			speed_allow <= 0;
		end
	endcase
end

always@(negedge clk) begin
	case(state) 
		idle_state: begin
			// do something
			id_reg <= 0;
			x_reg <= 0;
			y_reg <= 0;
			o_wen_location <= 0;
			o_wen_speed <= 0;
		end
		id_state: begin
			id_reg <= i_car;
			o_wen_speed <= 0;
			o_wen_location <= 0;
		end
		x_state: begin
			x_reg <= i_car;
		end
		y_state: begin
			y_reg <= i_car;
		end
		math_state: begin
			o_wen_speed <= speed_allow;
			o_wen_location <= 1;
		end
	endcase
end

endmodule




