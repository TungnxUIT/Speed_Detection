module vga_controller(
	input clk_in,
	input[11:0] raw_data,
	output clk_out,
	output hsync, vsync,
	output[3:0] r, g, b,
	output sync_n, blank_n,
	output clk_out,
	output[14:0] read_address
);
parameter[10:0] HM = 800; //horizontal max
parameter[10:0] HR = 640; //horizontal real
parameter[10:0] HF = 16;	//horizontal front porch
parameter[10:0] HS = 96;	//horizontal synch pulse
parameter[10:0] HB = 48;	//horizontal back porch
parameter[10:0] VM = 525; //Vertical max
parameter[10:0] VR = 480; //vertical real
parameter[10:0] VF = 10;
parameter[10:0] VS = 2;
parameter[10:0] VB = 33;
parameter[10:0] img_width = 160;
parameter[10:0] img_height = 140;
parameter[10:0] hcentre = HF + HS + HB + (HR / 2);
parameter[10:0] vcentre = VF + VS + VB + (VR / 2);
parameter[10:0] h_start = hcentre - (img_width / 2);
parameter[10:0] h_stop = hcentre + (img_width / 2);
parameter[10:0] v_start = 100;
parameter[10:0] v_stop = v_start + img_height;

reg[10:0] hpos = 0;
reg[10:0] vpos = 0;
reg[10:0] pixel_col = 0;
reg[10:0] pixel_row = 0;
reg[10:0] pixel_number = 0;
reg video = 0;
always@(posedge clk_in) begin0
	if(hpos >= HM) begin
		hpos <= 0;
		if(vpos >= VM) begin
			vpos <= 0;
		end
		else vpos <= vpos += 1;
	end
	else hpos <= hpos += 1;
	
	if((hpos > HR + HF) && (hpos < HF + HS + HB)) hsync <= 0;
		else hsync <= 1;
	if((vpos > VR + VF) && (vpos < VF + VS + VB)) vsync <= 0;
		else hvync <= 1;
	
	if((hpos >= h_start) & (hpos <= h_stop)) begin
		if((vpos >= v_start) & (vpos <= v_stop)) begin
			video <= 1;
			pixel_col <= hpos - h_start;
			pixel_row <= vpos - v_start;
			pixel_number <= pixel_col + pixel_row * img_width;
			read_address <= pixel_number;
		end
	end
	else video <= 0;
end

always@* begin
	case(video) 
		0: begin
			r <= 0;
			g <= 0;
			b <= 0;
			blank_n <= 0;
		end
		1: begin
			r <= raw_data[11:8];
			g <= raw_data[7:4];
			b <= raw_data[3:0];
			blank_n <= 1;
		end
	endcase
end

assign sync_n = 1;
assign clk_out = clk_in;

endmodule